---
export interface Props {
  serviceAreas: Array<{
    title: string;
    slug: string;
    lat?: number;
    lng?: number;
  }>;
  class?: string;
}

const { serviceAreas, class: className = "" } = Astro.props;

// Filter service areas that have coordinates
const serviceAreasWithCoords = serviceAreas.filter(area => area.lat && area.lng);
---

<div class={`cs-map-container ${className}`} id="service-areas-map" role="application" aria-label="Interactive map of service areas in North Alabama and Middle Tennessee">
  <div id="map" class="cs-map" aria-describedby="map-description"></div>
  <div id="map-description" class="sr-only">
    Interactive map showing our service coverage across North Alabama and Middle Tennessee. 
    The map displays markers for each city we serve. Click on any marker to view details about that service area.
    If you have difficulty using the map, please refer to the service areas list below.
  </div>
</div>

<script>
  import L from 'leaflet';
  import 'leaflet.markercluster';
  import 'leaflet/dist/leaflet.css';
  import 'leaflet.markercluster/dist/MarkerCluster.css';
  import 'leaflet.markercluster/dist/MarkerCluster.Default.css';

  // Fix for default markers in Leaflet with bundlers
  delete (L.Icon.Default.prototype as any)._getIconUrl;
  L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
    iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
  });

  let map: L.Map | null = null;
  let markers: any = null; // Using any to avoid TypeScript issues with MarkerClusterGroup
  let mapContainer: HTMLElement | null = null;
  let dataElement: HTMLElement | null = null;
  let isInitialized = false;

  function initializeMap() {
    mapContainer = document.getElementById('map');
    dataElement = document.getElementById('service-areas-data');
    
    if (!mapContainer || !dataElement) {
      console.warn('Map container or data element not found');
      return false;
    }

    // Clean up existing map if it exists
    if (map) {
      try {
        map.remove();
      } catch (e) {
        console.warn('Error removing existing map:', e);
      }
      map = null;
      markers = null;
    }

    // Clear the container
    mapContainer.innerHTML = '';

    try {
      // Get service areas data from the component
      const serviceAreasData = JSON.parse(dataElement.textContent || '[]');

      // Initialize map
      map = L.map('map', {
        zoomControl: true,
        scrollWheelZoom: true,
        doubleClickZoom: true,
        touchZoom: true,
        dragging: true,
        keyboard: true,
        keyboardPanDelta: 80,
        boxZoom: true,
        attributionControl: false,
        zoomSnap: 0.5,
        zoomDelta: 0.5,
        wheelPxPerZoomLevel: 120,
      });

      // Add tile layer with smooth CartoDB tiles
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '',
        subdomains: 'abcd',
        maxZoom: 20,
        minZoom: 6,
      }).addTo(map);

      // Create marker cluster group
      markers = (L as any).markerClusterGroup({
        chunkedLoading: true,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        maxClusterRadius: 50,
      });

      // Add markers for each service area
      const bounds = L.latLngBounds([]);
      
      serviceAreasData.forEach((area: any) => {
        if (area.lat && area.lng && markers) {
          const marker = L.marker([area.lat, area.lng]);
          
          // Create popup content
          const popupContent = `
            <div class="cs-map-popup">
              <h3 class="cs-popup-title">${area.title}</h3>
              <p class="cs-popup-description">Professional septic & excavation services</p>
              <a href="/service-areas/${area.slug}" class="cs-popup-link">
                Learn More
                <svg class="cs-popup-icon" width="16" height="16" viewBox="0 0 16 16" fill="none">
                  <path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </a>
            </div>
          `;
          
          marker.bindPopup(popupContent);
          markers.addLayer(marker);
          bounds.extend([area.lat, area.lng]);
        }
      });

      // Add marker cluster to map
      if (markers && map) {
        map.addLayer(markers);

        // Fit map to bounds with padding
        if (bounds.isValid()) {
          map.fitBounds(bounds, { 
            padding: [20, 20],
            maxZoom: 10 
          });
        } else {
          // Fallback center (roughly between Alabama and Tennessee)
          map.setView([35.0, -86.8], 8);
        }
      }

      // Handle responsive behavior
      function handleResize() {
        if (map) {
          setTimeout(() => {
            if (map) {
              map.invalidateSize();
            }
          }, 100);
        }
      }

      window.addEventListener('resize', handleResize);
      
      // Store cleanup function
      (window as any).cleanupServiceAreasMap = () => {
        window.removeEventListener('resize', handleResize);
        if (map) {
          try {
            map.remove();
          } catch (e) {
            console.warn('Error cleaning up map:', e);
          }
          map = null;
          markers = null;
        }
        isInitialized = false;
      };

      isInitialized = true;
      return true;

    } catch (error) {
      console.error('Error initializing map:', error);
      return false;
    }
  }

  // Check if map needs initialization
  function checkMapInitialization() {
    const container = document.getElementById('map');
    const data = document.getElementById('service-areas-data');
    
    if (container && data && (!isInitialized || !map || container.children.length === 0)) {
      console.log('Initializing map...');
      initializeMap();
    }
  }

  // Use multiple approaches to ensure map loads
  function setupMapWatchers() {
    // Method 1: Intersection Observer to detect when map container is visible
    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.target.id === 'map') {
            setTimeout(checkMapInitialization, 100);
          }
        });
      });

      const container = document.getElementById('map');
      if (container) {
        observer.observe(container);
      }

      // Store observer for cleanup
      (window as any).mapObserver = observer;
    }

    // Method 2: MutationObserver to detect DOM changes
    if ('MutationObserver' in window) {
      const mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList') {
            const mapContainer = document.getElementById('map');
            if (mapContainer && (!isInitialized || mapContainer.children.length === 0)) {
              setTimeout(checkMapInitialization, 200);
            }
          }
        });
      });

      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });

      // Store observer for cleanup
      (window as any).mapMutationObserver = mutationObserver;
    }

    // Method 3: Periodic check
    const intervalId = setInterval(() => {
      checkMapInitialization();
    }, 1000);

    // Store interval for cleanup
    (window as any).mapCheckInterval = intervalId;

    // Method 4: Focus event (when user returns to tab/window)
    window.addEventListener('focus', () => {
      setTimeout(checkMapInitialization, 300);
    });
  }

  // Initialize immediately if DOM is ready
  function initialize() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
          checkMapInitialization();
          setupMapWatchers();
        }, 100);
      });
    } else {
      // DOM is already loaded
      setTimeout(() => {
        checkMapInitialization();
        setupMapWatchers();
      }, 100);
    }
  }

  // Handle page visibility changes
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      setTimeout(checkMapInitialization, 200);
    }
  });

  // Handle page show event (fired when page is loaded from cache)
  window.addEventListener('pageshow', (event) => {
    setTimeout(checkMapInitialization, event.persisted ? 300 : 100);
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    // Clean up observers and intervals
    if ((window as any).mapObserver) {
      (window as any).mapObserver.disconnect();
    }
    if ((window as any).mapMutationObserver) {
      (window as any).mapMutationObserver.disconnect();
    }
    if ((window as any).mapCheckInterval) {
      clearInterval((window as any).mapCheckInterval);
    }
    if ((window as any).cleanupServiceAreasMap) {
      (window as any).cleanupServiceAreasMap();
    }
  });

  // Initial setup
  initialize();
</script>

<!-- Hidden data element for script access -->
<script type="application/json" id="service-areas-data" set:html={JSON.stringify(serviceAreasWithCoords)} />

<style lang="less">
  .cs-map-container {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    
    @media (min-width: 768px) {
      height: 500px;
    }
    
    @media (min-width: 1024px) {
      height: 600px;
    }
  }

  .cs-map {
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  // Screen reader only content
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  // Custom popup styles
  :global(.cs-map-popup) {
    text-align: center;
    padding: 0.5rem;
    min-width: 200px;
  }

  :global(.cs-popup-title) {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--primary);
    margin: 0 0 0.5rem 0;
  }

  :global(.cs-popup-description) {
    font-size: 0.875rem;
    color: var(--bodyTextColor);
    margin: 0 0 1rem 0;
  }

  :global(.cs-popup-link) {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background-color: var(--primary);
    color: white;
    text-decoration: none;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: 500;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: var(--primaryDark);
    }
  }

  :global(.cs-popup-icon) {
    width: 16px;
    height: 16px;
  }

  // Dark mode adjustments
  :global(.dark) {
    :global(.leaflet-container) {
      filter: hue-rotate(180deg) invert(1);
    }

    :global(.leaflet-popup-content-wrapper) {
      filter: hue-rotate(180deg) invert(1);
    }

    :global(.leaflet-popup-tip) {
      filter: hue-rotate(180deg) invert(1);
    }
  }
</style> 